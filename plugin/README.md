# 插件系统

- [插件系统](#插件系统)
  - [1. 介绍](#1-介绍)
  - [2. 插件编写](#2-插件编写)
    - [2.1. 插件规则](#21-插件规则)
    - [2.2. 插件编译](#22-插件编译)
  - [3. 最佳实践](#3-最佳实践)
  - [4. 为 C 语言编译静态/动态链接库](#4-为-c-语言编译静态动态链接库)
    - [4.1. 在插件代码中标记导出点](#41-在插件代码中标记导出点)
    - [4.2. 编译生成 C 头文件和静态链接库](#42-编译生成-c-头文件和静态链接库)
    - [4.3. 编译生成 C 动态链接库](#43-编译生成-c-动态链接库)
  - [5. 为 Go 程序编译动态链接库](#5-为-go-程序编译动态链接库)

插件系统为 Go 语言提供了动态加载模块的能力, 相当于 C/C++ 语言的"动态链接库", 即模块可以在"运行时加载", 并可以随时替换

> 插件系统从 Go 1.8 以上版本开始提供, 1.10 以上版本可以编译 macOS 系统上的插件

## 1. 介绍

和 C/C++ 类似, Go 语言的插件的编译结果也为一个 `.so` (或 `.dll`) 动态库文件, 主应用加载此动态库文件, 并通过查找动态库中的"符号"来导出动态库中定义的内容, 可以为一个"函数" 或 "类型" ("接口" 或 "结构体")

```golang
plug, err := plugin.Open("<插件文件名>")
if err != nil {
    panic(err)
}

symb, err := plug.Lookup("Create")
if err != nil {
    panic(err)
}
```

此时就可以从指定的插件文件中导出一个名为 `Create` 的符号, 可以通过该符号进一步访问插件中的程序

## 2. 插件编写

### 2.1. 插件规则

Go 语言的插件编写的规则比较简单, 只需要建立一个插件模块 (通过 `go mod init` 命令), 并提供一个名为 `main` 的子模块即可

### 2.2. 插件编译

在插件模块目录中, 通过如下命令即可将插件模块编译为动态库

```bash
go build -buildmode=plugin -o <输出文件路径>
```

此时会在指定的路径下生产 `.so` (或 `.dll`) 动态库文件

参照 [介绍](#1-介绍) 中提供的方式即可引入该插件动态库

## 3. 最佳实践

为了减少插件使用的复杂度, 充分利用 Go 语言特性, 建议按如下方式使用插件

1. 主程序定义一个接口 (`interface`), 该接口封装插件需导出的类型和方法. 由于 Go 语言使用 Duck Typing (鸭子类型), 所以接口代码无需引入任何类型依赖, 即可实现该定义的接口;
2. 插件代码中实现该接口, 并提供一个工厂函数 (例如 `Create`) 函数, 返回该接口对象的指针, 返回类型为 `interface{}`;
3. 在主程序中, 查找插件中工厂函数名称符号, 并将其转为 `func() interface{}` 类型 (本例中工厂函数未提供参数, 可以根据需要为 `Create` 函数提供必要的参数);
4. 将插件工厂函数返回的 `interface{}` 类型转为之前定义的接口类型, 调用其中方法完成插件调用;

参考 [app/main.go](./app/main.go) 中的代码实现

## 4. 为 C 语言编译静态/动态链接库

Go 语言提供了和 C 语言的互操作性, 即可以将 Go 插件编译为 C 语言能使用的静态/动态链接库

### 4.1. 在插件代码中标记导出点

```golang
package main

import "C"
import "fmt"

func main() {
    // 如果没有初始化代码, 则可以为空
}

// export Hello
func Hello(name string) {
    fmt.Println("output:", name)
}
```

1. 需要导出 `C` 模块, 即 `import "C"`;
2. 需要在导出点函数上提供注释, 即 `// export Hello`, 表示要导出 `Hello` 函数;

### 4.2. 编译生成 C 头文件和静态链接库

```bash
go build --buildmode=c-archive plugin.go
```

在 C 代码 (假设为 `c_app.c`) 中引入头文件, 完成代码后使用如下方式编译

```bash
gcc -o c_app c_app.c plugin.a -lpthread
```

### 4.3. 编译生成 C 动态链接库

```bash
go build --buildmode=c-shared -o libplugin.so plugin.go
```

安装 Linux 标准, 动态库的命名为 `lib` + `库名称` + `.so`

编译 C 并链接动态库的命令为

```bash
gcc  -o hello_dynamic c_app.c  -L./ -lplugin -lpthread
```

其中, `-L` 用于指定动态库 (`.so` 文件) 的路径, `-l` 用户指定动态库名称, `-lplugin` 表示引入名为 `libplugin.so` 的动态库文件

## 5. 为 Go 程序编译动态链接库

可以将一个 Go 模块安装为动态链接库, 在使用该模块时直接引入动态库而非 Go 源码

```bash
go install -buildmode=shared std # 安装 Go 标准库的动态库
go build -linkshared -o app app.go # 编译任意 Go 程序, 指定标准库使用动态库而非静态编译
```

这种方式可以减少编译后可执行文件的大小, 但部署时也必须连同 std 的动态库一起部署, 并不推荐
